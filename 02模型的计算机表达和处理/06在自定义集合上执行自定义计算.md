## **06 在自定义集合上执行自定义计算（数据抽象的核心实践）**

大家好。在前面我们认识了函数和过程抽象，现在我们将把焦点转向 **数据抽象（Data Abstraction）** 的核心实践：如何为我们自定义的数据结构（即 **自定义集合**）赋予生命，让它们能够像内置类型一样执行计算。

本期的核心论点是：

> **通过定义数据结构和重载运算符，我们可以在任何自定义集合上执行自定义的计算逻辑。这些运算符（如 `+`、`*`）本质上就是我们为该集合定义的特殊函数。**

我们将通过三个不同复杂度的例子来演示这一过程。

### **一、基础应用：有理数——定义数字集合上的运算**

**有理数（Rational Number）** 是最基础的自定义数字集合。它由两个整数组成（分子和分母），但它的加法和乘法运算与普通整数完全不同。

#### **1. 定义有理数的数据结构**

首先，我们定义一个结构体来封装有理数的两个组件：分子和分母。同时，为了保持数据的纯净，我们在创建时就执行 **约简** 操作（求最大公约数 `gcd`）。

**示例（Julia）：**

```julia
# 定义有理数结构体
struct RationalNumber
    numerator::Int64
    denominator::Int64
end

# 定义构造函数，确保创建时自动约简
function RationalNumber(numerator::Int64, denominator::Int64)
    # 确保分母非零
    if denominator == 0
        error("Denominator cannot be zero.")
    end
    # 求最大公约数并约简
    gcd_val = gcd(numerator, denominator)
    # 使用 new 关键字创建结构体的新实例
    new(numerator ÷ gcd_val, denominator ÷ gcd_val) 
end
```

#### **2. 为自定义集合定义计算函数（运算符）**

接下来，我们为 `RationalNumber` 集合定义 **加法** 运算。根据数学规则，两个有理数 $\\frac{a}{b} + \\frac{c}{d} = \\frac{ad + bc}{bd}$。

我们通过 **重载 `+` 运算符** 来实现这一逻辑。

**示例（Julia）：**

```julia
# 重载加法运算符 (+) 函数
function +(a::RationalNumber, b::RationalNumber)
    # 1. 执行有理数加法的函数逻辑
    numerator = a.numerator * b.denominator + b.numerator * a.denominator
    denominator = a.denominator * b.denominator
    
    # 2. 返回一个新的有理数对象（结果自动被构造函数约简）
    return RationalNumber(numerator, denominator)
end

# ----------------- 演示 -----------------
a = RationalNumber(1, 2) # 1/2
b = RationalNumber(3, 4) # 3/4

# 使用 + 符号，调用了我们自定义的函数
c = a + b 

# c 的结果 (1/2 + 3/4 = 5/4)
# (如果我们在 Julia 中重载了 Base.show，它会显示 5/4)
```

通过这个例子，我们证明了 **`+` 符号就是我们针对 `RationalNumber` 类型编写的一个特殊函数**。

-----

### **二、进阶应用：学生结构体——定义抽象的聚合运算**

我们还可以为**非数学**的数据结构定义抽象的聚合运算，来简化领域模型中的操作。例如，定义两个学生相加，代表合并他们的**特定属性**。

#### **1. 定义学生的数据结构**

我们定义一个 `Student` 结构体，包含姓名和体重。

**示例（Julia）：**

```julia
struct Student
    name::String
    weight::Float64 # 体重
end
```

#### **2. 定义抽象聚合函数（`+` 运算符）**

在这个自定义集合上，我们定义 **`+`** 运算符的含义为：**将两个学生的体重相加，并创建一个新的虚拟学生对象。**

**示例（Julia）：**

```julia
# 重载 + 运算符，用于合并学生的体重
function +(s1::Student, s2::Student)
    # 自定义的聚合逻辑：体重相加
    combined_weight = s1.weight + s2.weight
    
    # 返回一个新的 Student 结构体，名称表示合并
    return Student("Combined_$(s1.name)_$(s2.name)", combined_weight)
end

# ----------------- 演示 -----------------
student_a = Student("Alice", 50.5)
student_b = Student("Bob", 65.0)

# 执行自定义的聚合运算
group_total = student_a + student_b

# group_total.weight 结果为: 115.5
# 外部代码无需知道“相加”的具体实现，只需使用 + 即可。
```

-----

### **三、高级应用：符号求导——定义表达式集合上的高维运算**

在 **符号计算** 中，我们需要处理的集合不再是数值，而是 **代数表达式** 本身。求导（Differentiation）就是在这个**表达式集合**上执行的一种复杂运算。

#### **1. 表达式的数据抽象**

我们可以像 SICP 中那样，将数学表达式抽象为树状结构。例如，$x+3$ 是一个 **`Plus`** 结构，包含两个子表达式（一个 **`Variable`** $x$ 和一个 **`Number`** $3$）。

**示例（Julia：抽象代数结构）：**

```julia
# 抽象类型作为表达式的基类
abstract type Expr end

# 具体表达式类型：数字、变量、加法、乘法等
struct Number <: Expr; value::Float64; end
struct Variable <: Expr; name::Symbol; end
struct Plus <: Expr; expr1::Expr; expr2::Expr; end
struct Times <: Expr; expr1::Expr; expr2::Expr; end
```

#### **2. 定义求导函数（`diff`）**

求导是一个接受一个表达式集合（`Expr`）作为输入，返回另一个表达式集合作为结果的 **函数**。它的核心逻辑是 **多重分派**，根据输入表达式的类型应用不同的规则。

**演示：乘法定则（Product Rule）的函数实现**

当我们对 $u \\cdot v$ 求导时，需要应用 $(u \\cdot v)' = u' \\cdot v + u \\cdot v'$。这在代码中就是针对 `Times` 结构体定义的 `diff` 函数版本：

```julia
# 针对 Times 表达式结构体定义的求导函数（多重分派）
function diff(expr::Times, var::Symbol)
    # u' * v
    term1 = Times(diff(expr.expr1, var), expr.expr2)
    # u * v'
    term2 = Times(expr.expr1, diff(expr.expr2, var))
    
    # 返回 u' * v + u * v'
    return Plus(term1, term2)
end

# 演示：对 x*y 求导（需要实现 Number 和 Variable 的 diff）
# f = Times(Variable(:x), Variable(:y))
# df_dx = diff(f, :x) 
# df_dx 结果为表达式 Plus(Times(Number(1.0), Variable(:y)), Times(Variable(:x), Number(0.0)))
# (即 y + 0，经过简化函数后会得到 y)
```

在这个高级应用中，我们看到 **`diff` 函数** 不仅是针对自定义集合（`Expr`）的运算，它还体现了 **递归** 的力量：在计算 `Times` 的导数时，它递归地调用自身去计算子表达式 `expr1` 和 `expr2` 的导数，实现了复杂的链式法则。

总结来看，无论是简单的有理数、抽象的学生结构，还是复杂的代数表达式，**数据抽象** 都是通过 **自定义数据集合** 和 **定义该集合上的运算函数** 来实现的。