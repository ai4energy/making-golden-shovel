## **07 递归拓展：处理未知大小的复杂模型（最详尽解析）**

大家好。在过去的几期中，我们讨论了如何用对象来描述模型，以及用函数来处理这些对象。但我们所讨论的例子，都是规模已知、边界清晰的“小”模型。

那么问题来了：当面对一个我们不知道大小、甚至无限复杂的模型时，我们该如何进行描述和处理呢？这涉及到一些更高层次的抽象，以及一些强大的方法论。

-----

### **一、递归：处理未知大小模型的利器**

当一个模型的大小是未知的，或者可以无限扩展时，**递归（Recursion）** 就成为了最强大的处理方法。

**递归的核心思想是：** 一个问题可以分解为更小的、与原问题相同或类似的问题。

  * **描述模型：** 一个树状结构（如公司的组织架构或一个大型项目的依赖关系）就是一个典型的递归模型。一棵树由一个根节点和多个子树组成，而每个子树又可以被看作一棵完整的树。我们用递归的方式来描述它：$Tree = Node + (Tree\_1, Tree\_2, ...)$。
  * **处理模型：** 处理一个树状结构，我们可以采用递归函数。例如，一个计算文件夹大小的函数，它会先计算当前文件夹内所有文件的大小，然后 **递归调用自身**，去计算所有子文件夹的大小，并将结果累加。这个函数不知道文件夹有多少层，它只知道如何处理当前这一层，剩下的交给递归调用来完成。

**总结：** 这种方法让我们能够用简洁的代码，处理规模无限、结构未知的复杂模型。

-----

### **二、递归的概念、要素与流程**

**递归简介：** 递归是一种通过在函数或算法中 **调用自身** 来解决问题的方法。它基于将大问题分解成更小的相似子问题，并通过递归调用来解决这些子问题，最终达到解决整个问题的目的。

#### **1. 递归的基本要素**

递归的关键是要定义好以下两个要素：

1.  **基本情况（Base Case）：** 在递归函数内部定义一个或多个 **停止递归的条件**。例如，计算阶乘时，$1\! = 1$ 就是基本情况。
2.  **递归调用（Recursive Step）：** 在函数内部调用自身来解决更小规模的问题。

#### **2. 阶乘示例与执行流程**

我们以计算 **阶乘** 为例来说明递归过程：$n\! = n \\times (n-1)\!$。

**伪代码：**

```
function factorial(n):
    if n equals 1:  # 基本情况
        return 1
    else:           # 递归步
        return n * factorial(n-1) 
```

**执行流程（以计算 $5\!$ 为例）：**

1.  首先调用 `factorial(5)`。
2.  `n` 不等于 1，调用 `factorial(4)`。
3.  ... 过程继续，直到 $n$ 等于 1。
4.  `factorial(1)` 返回 **1**。（**递归终止**）
5.  `factorial(2)` 返回 $2 \\times 1$，即 **2**。
6.  `factorial(3)` 返回 $3 \\times 2$，即 **6**。
7.  `factorial(4)` 返回 $4 \\times 6$，即 **24**。
8.  `factorial(5)` 返回 $5 \\times 24$，即 **120**。（**最终结果**）

这个过程被称为 **递归深入** 和 **递归返回**，通常涉及到 **堆栈（Stack）** 的概念。

-----

### **三、递归在数学运算中的应用**

递归可以用来处理我们熟知的数学概念，从最基础的自然数生成到复杂的表达式计算。

#### **1. 自然数的产生与加减运算**

**自然数的产生：** 自然数是由 $1$ 和 **加 $1$（后继操作）** 产生的。我们可以用递归来定义这个序列的生成过程。

**Julia 示例：**

```julia
# 后继操作
function successor(n)
    return n + 1
end

# 生成自然数序列
function generate_natural_numbers(n)
    if n == 1
        return [1] # 基本情况
    else
        previous_sequence = generate_natural_numbers(n-1) # 递归调用
        current_number = successor(previous_sequence[end])
        return vcat(previous_sequence, [current_number])
    end
end
# generate_natural_numbers(5)  # 输出：[1, 2, 3, 4, 5]
```

**加法和减法运算：** 我们可以用递归来定义加法和减法，将它们转化为重复的后继或前驱操作：

```julia
# 递归加法：a + b = (a+1) + (b-1)，直到 b = 0
function add(a, b)
    if b == 0
        return a # 基本情况
    else
        return add(a + 1, b - 1) # 递归步
    end
end
# add(5, 3) # 输出：8
```

#### **2. 加减乘除四则混合运算（处理未知表达式）**

在处理包含加减乘除的表达式时，递归能够优雅地处理表达式的嵌套结构。

**Python 示例：**

```python
import random

# 递归计算表达式（假设表达式是某种树状结构）
def evaluate_expression(expr):
    if isinstance(expr, int):
        # 基本情况：如果当前节点是数字，则直接返回
        return expr
    
    # 递归步：如果当前节点是操作符
    op = expr 
    # 递归调用自身，获取左右叶子节点的值
    # 假设 rand_expression() 能够生成左右子表达式
    left = evaluate_expression(rand_expression())
    right = evaluate_expression(rand_expression())
    
    # 执行当前层的运算
    if op == '+':
        return left + right
    # ... 省略其他运算
```

-----

### **四、递归在符号计算与工程建模中的应用**

递归的思想在计算机科学的高级抽象中扮演了至关重要的角色。

#### **1. 符号求导中的递归（SICP 经典案例）**

符号求导是基于表达式的 **抽象语法树（AST）** 进行的，这是递归的最佳应用之一。

**核心思想：** 通过对表达式的类型进行 **多重分派**，并根据不同的求导规则进行 **递归处理**。

**SICP 乘法法则（Julia 表达）：**

对于表达式 $\\text{Times}(u, v)$，导数是 $\\text{Plus}(\\text{Times}(\\text{derive}(u)', v), \\text{Times}(u, \\text{derive}(v)' ))$。

```julia
# 假设我们有表达式结构体 Expr, Times, Plus 等

# 针对 Times 表达式结构体定义的求导函数
function derive(expr::Times, var::Symbol)
    # u'：递归调用 derive 函数
    u_prime = derive(expr.expr1, var) 
    # v'：递归调用 derive 函数
    v_prime = derive(expr.expr2, var)

    # 构造新的导数表达式集合：
    return Plus(
        Times(u_prime, expr.expr2), # u' * v
        Times(expr.expr1, v_prime)  # u * v'
    )
end
# 基本情况：
# function derive(expr::Number, var::Symbol) return 0 end
# function derive(expr::Variable, var::Symbol) return (expr.name == var) ? 1 : 0 end
```

#### **2. 能源系统与碳足迹计算中的递归思想**

能源系统建模和碳足迹计算都涉及复杂的 **层次化结构** 和 **未知规模** 的系统。

  * **从下到上构建：** 从最基本的组件开始（如发电机），用自定义的连接运算（如 **`+` 运算符重载**）将它们 **递归组合** 成更大的系统。
  * **从上到下展开（展平）：** 将复杂的层次结构转化为扁平的结构。通过递归遍历子系统和连接，将系统所有的变量表、参数表和方程表 **合并（取并集）** 起来，得到最终可计算的扁平化大系统。

**递归展平的伪代码：**

```
function flatten_system_properties(system):
    properties = system.local_properties 
    
    # 遍历子系统和连接，递归调用
    for subsystem in system.subsystems:
        sub_properties = flatten_system_properties(subsystem) # 递归调用
        properties = merge(properties, sub_properties) # 合并
        
    return properties
```

无论是计算 Greet 模型中汽车的制造周期碳排放（追溯复杂供应链网络），还是合并能源系统的变量，递归都能以优雅的方式处理这种 **嵌套和累加** 关系。

-----

### **总结：递归作为最高级的抽象工具**

从运算符、函数到递归，我们看到了一条清晰的抽象演进路径。递归作为最高级的过程抽象工具，其价值在于：

1.  **处理无限性：** 能够用有限的代码定义处理无限或未知规模的数据结构（如表达式树、深层系统）。
2.  **简洁性：** 它将问题分解为自身，使得代码结构与问题结构高度一致。
3.  **抽象化：** 程序员无需关心具体的执行深度，只需确保 **基本情况** 和 **递归步** 的逻辑正确。