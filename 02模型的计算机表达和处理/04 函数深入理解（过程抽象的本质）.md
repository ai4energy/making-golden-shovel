## **04 函数深入理解（过程抽象的本质与机制）**

大家好。在上一期中，我们认识了 **函数** 如何作为桥梁处理模型对象。本期，我们将深入 **过程抽象（Procedural Abstraction）** 的核心——函数的本质、约定与执行机制，并通过代码示例来演示这些概念。

### **一、过程抽象：函数的本质与形式**

**过程抽象** 是指将一系列操作封装为一个具名的、可重复使用的单元。在编程中，**函数（Function）** 是实现过程抽象最核心的体现。

与数学上的函数不同，编程中的函数（过程）不是一个纯粹的数学定义，而是一连串的操作实现一个功能。就算是求取数学的函数值（比如平方根），底层也是一系列的算术操作来实现。这就是函数。

#### **1. 具名函数：抓住与召唤**

**具名函数** 拥有明确的名称，它是函数的身份标识，使我们能够在代码的任何位置调用它。

> **给函数命名，就是为了抓住它，需要它时再召唤出来**，从而实现代码的重用和模块化。

**示例（Python）：**

```python
# 定义具名函数，封装计算动能的过程
def calculate_energy(mass, velocity):
    """计算动能 (E = 0.5 * m * v^2)"""
    return 0.5 * mass * velocity**2

# 通过名称召唤函数
energy = calculate_energy(10.0, 5.0)  # 结果: 125.0
```

#### **2. 匿名函数：无名 Lambda**

**匿名函数**（也称为 **Lambda 函数**）是没有显式名称的函数。它们常用于简单的、一次性的操作，或作为参数传递给高阶函数，增强了代码的简洁性和灵活性。

**示例（Julia）：**

```julia
# 1. 定义一个匿名函数并赋给变量
sum_of_squares = (x, y) -> x^2 + y^2
result = sum_of_squares(3, 4)  # 结果为 25

# 2. 作为高阶函数（如 map）的参数使用
numbers = [1, 2, 3, 4, 5]
# 使用匿名函数将数组中的元素平方
squared_numbers = map(x -> x^2, numbers) 
# squared_numbers 结果: [1, 4, 9, 16, 25]
```

**编程即写函数：** 可以说编程的核心就是编写函数。函数是编程中的基本构建块，它们封装了特定的操作或功能，通过函数调用来执行这些操作。

### **二、函数的约定与核心行为**

函数的行为受其定义和运行时环境的约束，是函数与其调用者之间的一种**契约（Contract）**。

#### **1. 参数与约定（输入契约）**

**函数的参数** 可以被视为函数与其调用者之间约定的输入。通过定义参数，我们规定了函数需要接受的输入，并建立了使用规范。参数约定包括：

1.  **参数数量与顺序：** 必须按照定义的数量和顺序传入。
2.  **参数类型：** 在强类型语言中，参数定义时指定类型，确保函数接收的参数符合类型的要求。

**示例（Julia，演示类型约定）：**

```julia
# 定义一个函数，明确约定参数类型为 Float64
function process_data(data::Float64)
    return data * 2.0
end

# 调用成功
result = process_data(10.5) 
```

#### **2. 返回值与副作用（输出与状态变化）**

函数执行完毕后，其结果可以从两个方面考察：

  * **有返回值：** 函数可以通过使用关键字（如 `return`）将计算结果传递出去。
  * **没有返回值 / 副作用：** 函数主要用于执行**副作用（Side Effects）**，即函数**改变了外部状态**。函数**可能改变参数的内容，也可能不改变**。例如：修改了传入的可变参数、修改了全局变量、或执行了 I/O 操作（如 `print`）。

**示例（Python 副作用）：**

```python
# 有返回值，无副作用（纯函数）
def add(x, y):
    return x + y

# 无返回值，有副作用
def append_element(lst, element):
    # 直接修改了传入的可变参数 lst 的内容
    lst.append(element) 

my_list = [10]
append_element(my_list, 20)
# my_list 现在是 [10, 20]，函数产生了副作用
```

#### **3. 调用与流程控制**

函数的调用是程序执行流的核心：

  * **函数调用与嵌套调用：** 在一个函数内部调用另一个函数，将复杂的任务分解为子任务。
  * **递归（Recursion）：** 函数在其定义中调用自身。它是解决需要重复执行相似操作的重要抽象方式。

**示例（Python 递归演示）：**

```python
def factorial(n):
    # 基线条件
    if n == 0:
        return 1
    # 递归步
    return n * factorial(n - 1) 
```

### **三、程序入口与运行时环境**

程序的执行需要一个明确的起点和一套完整的环境上下文。

#### **1. 程序入口与执行流**

**程序需要有个入口。** 不同的编程语言对于程序入口点的定义可能有所不同：

  * **C/C++/Go：** 显式的 **`main` 函数** 是入口。
  * **Julia：** **顺着 `.jl` 文件从头开始执行**，顶级代码就是入口。不同的编程语言有不同的程序入口约定。

**程序执行即函数调用：** 在一定意义上，**执行某个程序也相当于一个函数调用**。例如执行操作系统命令 **`ls`**。

> **此时，函数的参数是通过命令行参数给出。**

#### **2. 运行时环境与闭包**

函数的执行过程是依赖于其运行时环境的：

  * **环境变量：** **程序执行时的环境变量（键值对表）有可能也会影响函数的行为。** 环境变量是当前执行环境中的键值对表，包含了配置信息、路径设置等。

  * **执行比喻与压栈：**

    > **执行一个函数，就好比打游戏进入一扇门，保留现场就好比压栈，带入的技能集就好比环境。**

    函数调用时，程序会将当前执行的上下文和状态信息保存在 **栈** 上（**压栈**），执行完毕后，现场恢复（**出栈**）。

  * **闭包（Closure）：**

    > **运行时的环境，和入口，就构成一个闭包。就好比一下子穿越了。函数返回就穿越回来了。**

    闭包是函数对象以及它在定义时所处的环境的组合，它允许函数捕获并操作其定义时所在作用域中的非局部变量。

**示例（Python 闭包）：**

```python
def make_power_function(exponent):
    # 内部函数 power_func 捕获了外部函数的变量 exponent
    def power_func(base):
        return base ** exponent
    return power_func

# square_func 捕获了 exponent = 2 的环境，形成闭包
square_func = make_power_function(2) 

result = square_func(5)  # 结果: 25 (5^2)
```

### **四、函数的组织与多态**

#### **1. 函数的组织与服务**

**由函数可以构成服务。**

  * **服务与死循环：** 过去不让写死循环，现在 **daemon 程序就是死循环**。窗口界面程序也是死循环，基于事件做出响应。服务通常需要持续运行，以等待用户的输入或事件，并在接收到事件时做出相应的响应。

  * **工具与函数：** 可以认为 **`make` 也是一个函数，它的输入参数是 `makefile`**；**`cmake` 也是函数，它的输入是 `cmakelist.txt`**。

#### **2. 函数的多态性：函数重载与多重分派**

**同一个函数名，接受不同的参数类型，是一种进步，越来越对人友好。实际上是多重分发或者多态等设计实现的。**

  * **多重分派（Julia 演示）：** Julia 使用多分派（Multiple Dispatch）机制实现函数重载。它允许函数根据传入参数的 **类型** 来选择最匹配的函数版本（Method）进行调用。

<!-- end list -->

```julia
# 定义针对两个整数的 'add' 函数方法
function add(x::Int, y::Int)
    println("执行整数加法")
    return x + y
end

# 定义针对两个浮点数的 'add' 函数方法
function add(x::Float64, y::Float64)
    println("执行浮点数加法")
    return x + y
end

# 调用时 Julia 自动根据参数类型进行分派
add(2, 3)     # 调用 Int 版本，输出: 执行整数加法 
add(1.5, 2.5) # 调用 Float64 版本，输出: 执行浮点数加法 
```